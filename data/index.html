<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>USBFlashHub Control Panel</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%234CAF50'%3E%3Cpath d='M15 7v4h1v2h-3V5h2l-3-4-3 4h2v8h-3v-2h1V7H6v4H5v2h1v4h2v-4h1v-2H8V7h1V5H7v2H6v4H5v6h2v-2h1v4h8v-4h1v2h2v-6h-1V7h-1V5h-2v2h1v4h-1v2h1v4h-2v-4h1v-2h-1V7z'/%3E%3C/svg%3E">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            background: white;
            border-radius: 8px;
            padding: 20px 30px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        h1 {
            color: #333;
            font-size: 28px;
            margin-bottom: 10px;
            display: inline-block;
            cursor: text;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        h1:hover {
            background: #f5f5f5;
        }

        h1:focus {
            outline: 2px solid #4CAF50;
            background: #f0f9ff;
        }

        #systemName {
            cursor: text;
            padding: 2px 6px;
            border-radius: 3px;
            transition: background 0.2s;
        }

        #systemName:hover {
            background: #f5f5f5;
        }

        #systemName:focus {
            outline: 2px solid #4CAF50;
            background: #f0f9ff;
        }

        .status-bar {
            display: flex;
            gap: 30px;
            align-items: center;
            flex-wrap: wrap;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #666;
            font-size: 14px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #f44336;
            transition: all 0.3s ease;
        }

        .status-dot.connected {
            background: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .main-grid {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .panel h2 {
            font-size: 20px;
            margin-bottom: 15px;
            color: #333;
        }

        .hub-section {
            margin-bottom: 25px;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .hub-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            font-size: 18px;
        }

        .hub-controls {
            display: flex;
            gap: 30px;
            margin-bottom: 15px;
            padding: 12px;
            background: white;
            border-radius: 6px;
            border: 1px solid #ddd;
        }

        .hub-controls .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .hub-controls label {
            font-weight: 500;
            min-width: 100px;
            color: #555;
        }

        .ports-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
        }

        .port-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            padding: 12px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .port-card.active {
            border-color: #4CAF50;
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
        }

        .port-number {
            font-weight: bold;
            font-size: 14px;
            color: #555;
            margin-bottom: 8px;
        }

        .port-status {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #888;
        }

        .port-card.active .port-status {
            color: #4CAF50;
        }

        .port-name-input {
            width: 100%;
            padding: 4px 6px;
            margin-bottom: 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 11px;
            text-align: center;
            font-family: monospace;
        }

        .port-name-input:focus {
            outline: none;
            border-color: #4CAF50;
        }

        .port-name-input::placeholder {
            color: #aaa;
            font-style: italic;
        }

        .port-controls {
            display: flex;
            gap: 5px;
            justify-content: center;
        }

        .btn {
            padding: 4px 10px;
            border: none;
            border-radius: 4px;
            background: #e0e0e0;
            color: #333;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .btn:hover {
            transform: scale(1.05);
        }

        .btn-off {
            background: #f44336;
            color: white;
        }

        .btn-on {
            background: #4CAF50;
            color: white;
        }

        .btn-low {
            background: #2196F3;
            color: white;
        }

        .btn-high {
            background: #FF9800;
            color: white;
        }

        .btn-active {
            background: #673ab7;
            color: white;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(103, 58, 183, 0.3);
        }

        .btn-inactive {
            background: #9e9e9e;
            color: #666;
        }

        .control-section {
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }

        .control-group label {
            font-weight: 500;
            min-width: 100px;
        }

        .btn-control {
            padding: 8px 16px;
            background: #673ab7;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .btn-control:hover {
            background: #5e35b1;
        }

        .btn-control.danger {
            background: #f44336;
        }

        .btn-control.danger:hover {
            background: #d32f2f;
        }

        .activity-log {
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            background: #f5f5f5;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border: 1px solid #ddd;
        }

        /* Custom scrollbar styles */
        .activity-log::-webkit-scrollbar {
            width: 10px;
        }

        .activity-log::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .activity-log::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        .activity-log::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        .log-entry {
            padding: 4px 8px;
            margin-bottom: 2px;
            background: white;
            border-left: 3px solid #ddd;
            word-wrap: break-word;
        }

        .log-entry.error {
            border-left-color: #f44336;
            background: #ffebee;
        }

        .log-entry.success {
            border-left-color: #4CAF50;
            background: #e8f5e9;
        }

        .log-time {
            color: #888;
            margin-right: 8px;
        }

        .pin-state {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 500;
            margin-left: 5px;
        }

        .pin-state.high {
            background: #4CAF50;
            color: white;
        }

        .pin-state.low {
            background: #f44336;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ðŸ”Œ <span id="systemName" contenteditable="true" spellcheck="false" onblur="saveSystemName(this)" onkeydown="if(event.key==='Enter'){event.preventDefault();this.blur()}" data-original="USBFlashHub">USBFlashHub</span> Control Panel</h1>
            <div class="status-bar">
                <div class="status-item">
                    <div class="status-dot" id="wsStatus"></div>
                    <span id="connectionStatus">Connecting...</span>
                </div>
                <div class="status-item">
                    <span id="ipAddress">IP: -</span>
                </div>
                <div class="status-item">
                    <span id="uptime">Uptime: -</span>
                </div>
            </div>
        </header>

        <div class="main-grid">
            <div class="panel">
                <h2>USB Hub Control</h2>
                <div id="hubsContainer">
                    <!-- Hubs will be generated dynamically -->
                </div>
            </div>

            <div class="panel">
                <h2>Pin Control</h2>
                <div class="control-section">
                    <div class="control-group">
                        <label>Boot Pin:</label>
                        <span id="bootState" class="pin-state low">LOW</span>
                        <button class="btn-control" onclick="setPinState('boot', true)">HIGH</button>
                        <button class="btn-control" onclick="setPinState('boot', false)">LOW</button>
                    </div>
                    <div class="control-group">
                        <label>Reset Pin:</label>
                        <span id="resetState" class="pin-state high">HIGH</span>
                        <button class="btn-control" onclick="setPinState('reset', true)">Assert</button>
                        <button class="btn-control" onclick="setPinState('reset', false)">Release</button>
                        <button class="btn-control" onclick="pulseReset()">Pulse</button>
                    </div>
                    <div class="control-group">
                        <label>External 5V Relay:</label>
                        <span id="relayState" class="pin-state low">OFF</span>
                        <button class="btn-control" onclick="setRelayState(true)">ON</button>
                        <button class="btn-control" onclick="setRelayState(false)">OFF</button>
                    </div>
                </div>

                <div class="control-section">
                    <h3 style="font-size: 16px; margin-bottom: 10px;">Quick Actions</h3>
                    <button class="btn-control danger" onclick="allOff()">âš¡ All Ports Off</button>
                    <button class="btn-control" onclick="refreshStatus()">ðŸ”„ Refresh Status</button>
                </div>
            </div>
        </div>

        <div class="panel">
            <h2>Activity Log</h2>
            <div class="activity-log" id="activityLog">
                <!-- Log entries will be added here -->
            </div>
        </div>

        <div class="panel">
            <h2>System Status</h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px; margin: 15px 0;">
                <!-- Memory Section -->
                <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 3px solid #4CAF50;">
                    <h3 style="margin: 0 0 10px 0; font-size: 14px; color: #4CAF50;">Memory</h3>
                    <div style="display: grid; gap: 8px; font-size: 13px;">
                        <div><span style="color: #888;">Free Heap (SRAM):</span> <span id="freeHeap" style="float: right; color: #fff;">-</span></div>
                        <div><span style="color: #888;">Min Free Heap:</span> <span id="minFreeHeap" style="float: right; color: #fff;">-</span></div>
                        <div id="psramStatsContainer" style="display: none;">
                            <div style="border-top: 1px solid #444; margin: 8px 0; padding-top: 8px;"></div>
                            <div><span style="color: #888;">Free PSRAM:</span> <span id="freePsram" style="float: right; color: #fff;">-</span></div>
                            <div><span style="color: #888;">Min Free PSRAM:</span> <span id="minFreePsram" style="float: right; color: #fff;">-</span></div>
                        </div>
                    </div>
                </div>

                <!-- System Info Section -->
                <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 3px solid #2196F3;">
                    <h3 style="margin: 0 0 10px 0; font-size: 14px; color: #2196F3;">System</h3>
                    <div style="display: grid; gap: 8px; font-size: 13px;">
                        <div><span style="color: #888;">CPU Freq:</span> <span id="cpuFreq" style="float: right; color: #fff;">-</span></div>
                        <div><span style="color: #888;">Temperature:</span> <span id="temperature" style="float: right; color: #fff;">-</span></div>
                        <div><span style="color: #888;">SDK Version:</span> <span id="sdkVersion" style="float: right; color: #fff; font-size: 11px;">-</span></div>
                    </div>
                </div>

                <!-- WiFi Section -->
                <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 3px solid #FF9800;">
                    <h3 style="margin: 0 0 10px 0; font-size: 14px; color: #FF9800;">Network</h3>
                    <div style="display: grid; gap: 8px; font-size: 13px;">
                        <div><span style="color: #888;">WiFi SSID:</span> <span id="wifiSsid" style="float: right; color: #fff;">-</span></div>
                        <div><span style="color: #888;">WiFi RSSI:</span> <span id="wifiRssi" style="float: right; color: #fff;">-</span></div>
                    </div>
                </div>

                <!-- I2C Health Section -->
                <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; border-left: 3px solid #9C27B0;">
                    <h3 style="margin: 0 0 10px 0; font-size: 14px; color: #9C27B0;">I2C Health</h3>
                    <div style="display: grid; gap: 8px; font-size: 13px;">
                        <div><span style="color: #888;">Total TX:</span> <span id="i2cTotal" style="float: right; color: #fff;">0</span></div>
                        <div><span style="color: #888;">Failed:</span> <span id="i2cFailed" style="float: right; color: #fff;">0</span></div>
                        <div><span style="color: #888;">Error Rate:</span> <span id="i2cErrorRate" style="float: right; color: #fff;">0%</span></div>
                        <div><span style="color: #888;">Last Success:</span> <span id="i2cLastSuccess" style="float: right; color: #fff; font-size: 11px;">-</span></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let ws;
        let reconnectTimer;
        let pingTimer;
        let pongTimeout;
        let lastPongTime = 0;
        let bootPinState = false;
        let resetPinState = true;
        let versionCheckTimer;
        let currentVersion = null;
        let connectionHealthy = false;
        window.portNames = {};

        function stopKeepalive() {
            if (pingTimer) {
                clearInterval(pingTimer);
                pingTimer = null;
            }
            if (pongTimeout) {
                clearTimeout(pongTimeout);
                pongTimeout = null;
            }
        }

        function startKeepalive() {
            stopKeepalive();
            lastPongTime = Date.now();

            // Send ping every 5 seconds
            pingTimer = setInterval(() => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({cmd: 'ping'}));

                    // Set timeout to detect no pong response
                    pongTimeout = setTimeout(() => {
                        const timeSincePong = Date.now() - lastPongTime;
                        if (timeSincePong > 10000) {
                            console.error('WebSocket keepalive timeout - no pong received');
                            addLog('Connection timeout - no response from device', 'error');
                            connectionHealthy = false;
                            ws.close();
                        }
                    }, 10000);
                }
            }, 5000);
        }

        function checkVersion() {
            fetch('/version')
                .then(response => response.json())
                .then(data => {
                    const newVersion = data.size;

                    if (currentVersion === null) {
                        // First check - just store version
                        currentVersion = newVersion;
                        console.log('UI version initialized:', currentVersion, 'bytes');
                    } else if (currentVersion !== newVersion) {
                        // Version changed - prompt for reload
                        console.warn('UI version changed:', currentVersion, '->', newVersion);
                        showReloadBanner();
                        currentVersion = newVersion;
                    }
                })
                .catch(err => {
                    console.error('Version check failed:', err);
                });
        }

        function showReloadBanner() {
            // Check if banner already exists
            if (document.getElementById('reloadBanner')) return;

            const banner = document.createElement('div');
            banner.id = 'reloadBanner';
            banner.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; background: #FF9800; color: white; padding: 12px 20px; text-align: center; z-index: 10000; box-shadow: 0 2px 8px rgba(0,0,0,0.3); font-weight: 500;';
            banner.innerHTML = 'âš  UI has been updated. <button onclick="location.reload()" style="margin-left: 15px; padding: 6px 20px; background: white; color: #FF9800; border: none; border-radius: 4px; font-weight: bold; cursor: pointer;">Reload Now</button>';
            document.body.insertBefore(banner, document.body.firstChild);
        }

        function startVersionCheck() {
            if (versionCheckTimer) {
                clearInterval(versionCheckTimer);
            }

            // Check immediately on start
            checkVersion();

            // Then check every 60 seconds
            versionCheckTimer = setInterval(checkVersion, 60000);
        }

        function stopVersionCheck() {
            if (versionCheckTimer) {
                clearInterval(versionCheckTimer);
                versionCheckTimer = null;
            }
        }

        function clearStaleData() {
            // Clear hub display
            const hubsContainer = document.getElementById('hubsContainer');
            hubsContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #f44336; background: #ffebee; border-radius: 4px; border: 2px solid #f44336;"><strong>âš  Disconnected</strong><br/>Waiting for connection...</div>';

            // Clear system stats
            document.getElementById('ipAddress').textContent = 'IP: -';
            document.getElementById('uptime').textContent = 'Uptime: -';
            document.getElementById('freeHeap').textContent = '-';
            document.getElementById('minFreeHeap').textContent = '-';
            document.getElementById('freePsram').textContent = '-';
            document.getElementById('minFreePsram').textContent = '-';
            document.getElementById('cpuFreq').textContent = '-';
            document.getElementById('wifiSsid').textContent = '-';
            document.getElementById('wifiRssi').textContent = '-';
            document.getElementById('temperature').textContent = '-';
            document.getElementById('sdkVersion').textContent = '-';
            document.getElementById('i2cTotal').textContent = '0';
            document.getElementById('i2cFailed').textContent = '0';
            document.getElementById('i2cErrorRate').textContent = '0%';
            document.getElementById('i2cLastSuccess').textContent = '-';

            addLog('Connection lost - data cleared', 'error');
        }

        function initWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsHost = window.location.hostname;
            const wsUrl = `${protocol}//${wsHost}:81`;
            console.log('Connecting to WebSocket:', wsUrl);
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('WebSocket connected');
                document.getElementById('wsStatus').classList.add('connected');
                document.getElementById('connectionStatus').textContent = 'Connected';
                connectionHealthy = true;
                clearTimeout(reconnectTimer);
                startKeepalive();
                refreshStatus();
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    // Only update lastPongTime on actual pong responses
                    if (data.status === 'ok' && data.msg === 'pong') {
                        lastPongTime = Date.now();
                        connectionHealthy = true;
                        if (pongTimeout) {
                            clearTimeout(pongTimeout);
                            pongTimeout = null;
                        }
                    }
                    handleMessage(data);
                } catch (e) {
                    console.error('Failed to parse message:', e);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                addLog(`WebSocket error: Cannot connect to ws://${wsHost}:81`, 'error');
                connectionHealthy = false;
                stopKeepalive();
                clearStaleData();
            };

            ws.onclose = () => {
                document.getElementById('wsStatus').classList.remove('connected');
                document.getElementById('connectionStatus').textContent = 'Disconnected';
                connectionHealthy = false;
                stopKeepalive();
                clearStaleData();
                reconnectTimer = setTimeout(initWebSocket, 3000);
            };
        }

        function sendCommand(cmd) {
            // Check if connection is healthy (not just OPEN)
            if (ws && ws.readyState === WebSocket.OPEN && connectionHealthy) {
                try {
                    ws.send(JSON.stringify(cmd));
                    return true;
                } catch (e) {
                    console.error('WebSocket send failed:', e);
                    addLog('Connection error - reconnecting...', 'error');
                    connectionHealthy = false;
                    ws.close();
                    return false;
                }
            }

            // Connection is not healthy - show error and try to recover
            console.error('WebSocket not connected or unhealthy');
            if (!connectionHealthy && ws && ws.readyState === WebSocket.OPEN) {
                // Socket appears open but is unhealthy - force close and reconnect
                console.warn('Forcing reconnect of unhealthy connection');
                addLog('Connection appears stuck - forcing reconnect...', 'error');
                ws.close();
            } else if (!ws || ws.readyState === WebSocket.CLOSED) {
                addLog('Not connected - attempting reconnect...', 'error');
                initWebSocket();
            }
            return false;
        }

        function handleMessage(data) {
            console.log('Received message:', data);

            // Handle real-time log entry
            if (data.type === 'log_entry') {
                addLogEntryFromServer(data);
            }

            // Handle port names from status response
            if (data.portnames !== undefined) {
                window.portNames = data.portnames;
            }

            // Handle system name from status response
            if (data.systemname !== undefined) {
                const nameElement = document.getElementById('systemName');
                nameElement.textContent = data.systemname;
                nameElement.dataset.original = data.systemname;
                document.title = data.systemname + ' Control Panel';
            }

            // Handle status response that includes hubs info
            if (data.hubs !== undefined) {
                updateHubs(data.hubs);
            }

            if (data.log) {
                updateLog(data.log);
            }
            if (data.system) {
                updateSystem(data.system);
            }
            if (data.i2c) {
                updateI2CHealth(data.i2c);
            }
            if (data.pins) {
                updatePinStates(data.pins);
            }
            if (data.relay) {
                updateRelayState(data.relay);
            }
            if (data.network) {
                if (data.network.ip) {
                    document.getElementById('ipAddress').textContent = `IP: ${data.network.ip}`;
                }
            }
            if (data.uptime) {
                const hours = Math.floor(data.uptime / 3600000);
                const minutes = Math.floor((data.uptime % 3600000) / 60000);
                document.getElementById('uptime').textContent = `Uptime: ${hours}h ${minutes}m`;
            }
            if (data.status === 'error') {
                addLog(`Error: ${data.msg} ${data.detail || ''}`, 'error');
            }
            if (data.status === 'ok' && data.msg && data.msg !== 'pong') {
                addLog(data.msg, 'success');
            }
        }

        function updateHubs(hubsData) {
            const container = document.getElementById('hubsContainer');

            // Don't rebuild if user is actively editing a port name
            const activeInput = document.activeElement;
            if (activeInput && activeInput.classList.contains('port-name-input')) {
                console.log('Skipping hub update - user is editing port name');
                return;
            }

            container.innerHTML = '';

            if (!hubsData || hubsData.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">No USB hubs detected</div>';
                return;
            }

            hubsData.forEach(hub => {
                const hubDiv = document.createElement('div');
                hubDiv.className = 'hub-section';

                // Create hub header with controls
                const headerHTML = `
                    <h3>Hub ${hub.num} (Address: 0x${hub.addr.toString(16).toUpperCase()})</h3>
                    <div class="hub-controls">
                        <div class="control-group">
                            <label>Power Limit:</label>
                            <button class="btn ${hub.power === 'low' ? 'btn-active' : 'btn-inactive'}" onclick="setHubPower(${hub.num}, false)">Low</button>
                            <button class="btn ${hub.power === 'high' ? 'btn-active' : 'btn-inactive'}" onclick="setHubPower(${hub.num}, true)">High</button>
                        </div>
                        <div class="control-group">
                            <label>Hub LEDs:</label>
                            <button class="btn ${!hub.led ? 'btn-active' : 'btn-inactive'}" onclick="setHubLED(${hub.num}, false)">Off</button>
                            <button class="btn ${hub.led ? 'btn-active' : 'btn-inactive'}" onclick="setHubLED(${hub.num}, true)">On</button>
                        </div>
                    </div>
                    <div class="ports-row"></div>
                `;
                hubDiv.innerHTML = headerHTML;

                const portsRow = hubDiv.querySelector('.ports-row');

                // Add port controls - simple on/off since power is controlled at hub level
                hub.ports.forEach(port => {
                    const portCard = document.createElement('div');
                    portCard.className = `port-card ${port.enabled ? 'active' : ''}`;

                    // Get port name from global portNames object (if available)
                    const portName = window.portNames ? (window.portNames[port.num] || '') : '';

                    portCard.innerHTML = `
                        <div class="port-number">Port ${port.num}</div>
                        <input type="text" class="port-name-input"
                               placeholder="Name..."
                               value="${portName}"
                               data-original="${portName}"
                               data-port="${port.num}"
                               maxlength="10"
                               pattern="[A-Za-z0-9_-]*"
                               onblur="savePortNameIfChanged(this)"
                               onkeypress="if(event.key==='Enter') this.blur()">
                        <div class="port-status">${port.enabled ? 'ON' : 'OFF'}</div>
                        <div class="port-controls">
                            <button class="btn btn-off" onclick="setPort(${port.num}, 'off')">Off</button>
                            <button class="btn btn-on" onclick="setPort(${port.num}, 'on')">On</button>
                        </div>
                    `;
                    portsRow.appendChild(portCard);
                });

                container.appendChild(hubDiv);
            });
        }

        function setPort(port, state) {
            const success = sendCommand({ cmd: 'port', port: port, enable: state === 'on' });
            if (success) {
                // Give immediate visual feedback
                console.log(`Port ${port} command sent: ${state}`);
            } else {
                addLog(`Failed to send port ${port} command - not connected`, 'error');
            }
        }

        function setHubPower(hubNum, high) {
            const powerLevel = high ? 'high' : 'low';
            if (sendCommand({ cmd: 'hub', hub: hubNum, power: powerLevel })) {
                // Request status update after a short delay
                setTimeout(() => sendCommand({ cmd: 'status' }), 100);
            } else {
                addLog(`Failed to send hub power command - not connected`, 'error');
            }
        }

        function setHubLED(hubNum, on) {
            if (sendCommand({ cmd: 'hub', hub: hubNum, led: on })) {
                // Request status update after a short delay
                setTimeout(() => sendCommand({ cmd: 'status' }), 100);
            } else {
                addLog(`Failed to send hub LED command - not connected`, 'error');
            }
        }

        function savePortNameIfChanged(input) {
            const port = parseInt(input.dataset.port);
            const newName = input.value.trim();
            const originalName = input.dataset.original;

            // Only save if value changed
            if (newName === originalName) {
                return;
            }

            setPortName(port, newName);
        }

        function setPortName(port, name) {
            // Validate name: max 10 chars, alphanumeric/_/- only
            if (name && name.length > 10) {
                addLog(`Port name too long (max 10 chars)`, 'error');
                return;
            }
            if (name && !/^[A-Za-z0-9_-]*$/.test(name)) {
                addLog(`Invalid port name (only letters, numbers, _ and - allowed)`, 'error');
                return;
            }

            // Send command to set port name
            if (sendCommand({ cmd: 'portname', port: port, name: name })) {
                // Update local cache
                window.portNames[port] = name;
                // Request status update to refresh UI
                setTimeout(() => sendCommand({ cmd: 'status' }), 100);
            } else {
                addLog(`Failed to set port name - not connected`, 'error');
            }
        }

        function saveSystemName(element) {
            const newName = element.textContent.trim();
            const originalName = element.dataset.original;

            // Only save if value changed
            if (newName === originalName) {
                return;
            }

            // Validate: max 15 chars, alphanumeric/_/- only, no spaces
            if (newName.length === 0 || newName.length > 15) {
                addLog(`System name must be 1-15 characters`, 'error');
                element.textContent = originalName;
                return;
            }
            if (!/^[A-Za-z0-9_-]+$/.test(newName)) {
                addLog(`Invalid system name (only letters, numbers, _ and - allowed, no spaces)`, 'error');
                element.textContent = originalName;
                return;
            }

            // Send command to set system name
            if (sendCommand({ cmd: 'systemname', name: newName })) {
                element.dataset.original = newName;
                document.title = newName + ' Control Panel';
                addLog(`System name updated: ${newName}`, 'success');
            } else {
                addLog(`Failed to set system name - not connected`, 'error');
                element.textContent = originalName;
            }
        }

        function setPinState(pin, state) {
            if (sendCommand({ cmd: pin, state: state })) {
                // Update UI immediately but don't log - server will send confirmation
                if (pin === 'boot') {
                    bootPinState = state;
                    document.getElementById('bootState').className = `pin-state ${state ? 'high' : 'low'}`;
                    document.getElementById('bootState').textContent = state ? 'HIGH' : 'LOW';
                } else if (pin === 'reset') {
                    resetPinState = state;
                    document.getElementById('resetState').className = `pin-state ${state ? 'high' : 'low'}`;
                    document.getElementById('resetState').textContent = state ? 'HIGH' : 'LOW';
                }
            } else {
                addLog(`Failed to send ${pin} command - not connected`, 'error');
            }
        }

        function pulseReset() {
            sendCommand({ cmd: 'reset', pulse: 100 });
        }

        function setRelayState(state) {
            if (sendCommand({ cmd: 'relay', state: state })) {
                // Update UI immediately
                document.getElementById('relayState').className = `pin-state ${state ? 'high' : 'low'}`;
                document.getElementById('relayState').textContent = state ? 'ON' : 'OFF';
            } else {
                addLog('Failed to send relay command - not connected', 'error');
            }
        }

        function allOff() {
            if (confirm('Turn off all ports?')) {
                if (sendCommand({ cmd: 'alloff' })) {
                    addLog('Turning off all ports...', 'success');
                    // Request status update after a short delay
                    setTimeout(() => sendCommand({ cmd: 'status' }), 100);
                } else {
                    addLog('Failed to send all off command - not connected', 'error');
                }
            }
        }

        function refreshStatus() {
            // Check if WebSocket is connected, reconnect if needed
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addLog('WebSocket disconnected, reconnecting...', 'error');
                initWebSocket();
                // Try to refresh after reconnection
                setTimeout(() => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        sendCommand({ cmd: 'status' });
                        sendCommand({ cmd: 'log' });
                    }
                }, 1000);
            } else {
                sendCommand({ cmd: 'status' });
                sendCommand({ cmd: 'log' });
            }
        }

        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function updateSystem(system) {
            if (system.ip) {
                document.getElementById('ipAddress').textContent = `IP: ${system.ip}`;
            }
            if (system.uptime) {
                const hours = Math.floor(system.uptime / 3600000);
                const minutes = Math.floor((system.uptime % 3600000) / 60000);
                document.getElementById('uptime').textContent = `Uptime: ${hours}h ${minutes}m`;
            }

            // Update enhanced system status
            if (system.free_heap !== undefined) {
                document.getElementById('freeHeap').textContent = formatBytes(system.free_heap);
            }
            if (system.min_free_heap !== undefined) {
                document.getElementById('minFreeHeap').textContent = formatBytes(system.min_free_heap);
            }
            // PSRAM stats (if available)
            if (system.free_psram !== undefined) {
                document.getElementById('freePsram').textContent = formatBytes(system.free_psram);
                document.getElementById('psramStatsContainer').style.display = 'block';
            }
            if (system.min_free_psram !== undefined) {
                document.getElementById('minFreePsram').textContent = formatBytes(system.min_free_psram);
            }
            if (system.cpu_freq !== undefined) {
                document.getElementById('cpuFreq').textContent = system.cpu_freq;
            }
            if (system.wifi_ssid !== undefined) {
                document.getElementById('wifiSsid').textContent = system.wifi_ssid;
            }
            if (system.wifi_rssi !== undefined) {
                document.getElementById('wifiRssi').textContent = system.wifi_rssi;
            }
            if (system.temperature !== undefined) {
                document.getElementById('temperature').textContent = system.temperature.toFixed(1) + 'Â°C';
            } else {
                document.getElementById('temperature').textContent = 'N/A';
            }
            if (system.sdk_version !== undefined) {
                document.getElementById('sdkVersion').textContent = system.sdk_version;
            }
        }

        function updateI2CHealth(i2c) {
            if (i2c.total_transactions !== undefined) {
                document.getElementById('i2cTotal').textContent = i2c.total_transactions;
            }
            if (i2c.failed_transactions !== undefined) {
                document.getElementById('i2cFailed').textContent = i2c.failed_transactions;
            }
            if (i2c.error_rate !== undefined) {
                const rate = document.getElementById('i2cErrorRate');
                rate.textContent = i2c.error_rate.toFixed(2);
                // Color code based on error rate
                if (i2c.error_rate > 10) {
                    rate.style.color = '#ff6b6b';
                } else if (i2c.error_rate > 5) {
                    rate.style.color = '#ffa500';
                } else {
                    rate.style.color = '#4CAF50';
                }
            }
            if (i2c.last_success_ago !== undefined) {
                const ms = i2c.last_success_ago;
                let timeStr;
                if (ms < 1000) timeStr = ms + 'ms ago';
                else if (ms < 60000) timeStr = (ms / 1000).toFixed(1) + 's ago';
                else timeStr = (ms / 60000).toFixed(1) + 'm ago';
                document.getElementById('i2cLastSuccess').textContent = timeStr;
            }
        }

        function updatePinStates(pins) {
            if (pins.boot !== undefined) {
                bootPinState = pins.boot;
                document.getElementById('bootState').className = `pin-state ${pins.boot ? 'high' : 'low'}`;
                document.getElementById('bootState').textContent = pins.boot ? 'HIGH' : 'LOW';
            }
            if (pins.reset !== undefined) {
                resetPinState = pins.reset;
                document.getElementById('resetState').className = `pin-state ${pins.reset ? 'high' : 'low'}`;
                document.getElementById('resetState').textContent = pins.reset ? 'HIGH' : 'LOW';
            }
        }

        function updateRelayState(relay) {
            if (relay.state !== undefined) {
                document.getElementById('relayState').className = `pin-state ${relay.state ? 'high' : 'low'}`;
                document.getElementById('relayState').textContent = relay.state ? 'ON' : 'OFF';
            }
        }

        function updateLog(logData) {
            const logDiv = document.getElementById('activityLog');
            if (Array.isArray(logData)) {
                // Clear and rebuild entire log when receiving full log from firmware
                logDiv.innerHTML = '';

                // Firmware sends entries newest-first, append them directly
                logData.forEach(entry => {
                    // Build message from firmware log entry structure
                    let msg = entry.action || entry.msg || '';
                    // Detail now contains [hub:port] format, so show it directly
                    if (entry.detail) msg += ` ${entry.detail}`;

                    // Append directly (don't use addLogEntry which inserts at top)
                    const logEntry = document.createElement('div');
                    logEntry.className = `log-entry ${entry.type || ''}`;
                    logEntry.innerHTML = `<span class="log-time">${entry.time}</span>${msg}`;
                    logDiv.appendChild(logEntry);
                });
            }
        }

        function addLogEntryFromServer(entry) {
            const logDiv = document.getElementById('activityLog');

            // Build message from firmware log entry structure
            let msg = entry.action || '';
            // Detail now contains [hub:port] format
            if (entry.detail) msg += ` ${entry.detail}`;

            // Create log entry and insert at top for real-time display
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${entry.type || ''}`;
            logEntry.innerHTML = `<span class="log-time">${entry.time}</span>${msg}`;
            logDiv.insertBefore(logEntry, logDiv.firstChild);

            // Keep only last 100 entries
            while (logDiv.children.length > 100) {
                logDiv.removeChild(logDiv.lastChild);
            }
        }

        function addLog(message, type = '') {
            const now = new Date();
            const time = now.toTimeString().split(' ')[0];
            addLogEntry(time, message, type);
        }

        function addLogEntry(time, message, type = '') {
            const logDiv = document.getElementById('activityLog');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.innerHTML = `<span class="log-time">${time}</span>${message}`;
            logDiv.insertBefore(entry, logDiv.firstChild);

            // Keep only last 100 entries
            while (logDiv.children.length > 100) {
                logDiv.removeChild(logDiv.lastChild);
            }
        }

        // Initialize on page load
        window.addEventListener('load', () => {
            initWebSocket();
            startVersionCheck();
        });
    </script>
</body>
</html>